<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About1" xml:space="preserve">
    <value>This application uses standrd OS's file API (WinAPI on Windows, POSIX on Mac and NDK on Android) to measure the speed of data transfer (in Megabytes per Second) between storage device (HDD, SSD, USB flash drive) and system memory(RAM). API calls are done through .NET Framewor/Mono.</value>
  </data>
  <data name="About2" xml:space="preserve">
    <value>Tests include sequential read and sequential write measurements, where big (megabytes) chunks of data are transfered sequentialy. These tests are representative of such disk operstions as large file copying, video encoding/decoding etc.</value>
  </data>
  <data name="About3" xml:space="preserve">
    <value>Random tests run for half a minute each and do transfers in small chunks (4KB) at random positions within test file. These tests show how file subsystem's performance influnce applications' load times, copying multiple small files, runnning database queries etc.</value>
  </data>
  <data name="About4" xml:space="preserve">
    <value>In 'Options' section you might find settings which may influence test results:</value>
  </data>
  <data name="About5" xml:space="preserve">
    <value>' Write buffering - influences write test. Write operations use intermediary memory buffer and postpone data commit to latter more convinient time for better performace at a cost of less resiliant writes (e.g. power failure and not commiting to disk write buffer contents).</value>
  </data>
  <data name="About6" xml:space="preserve">
    <value>' In-memory file cache - influences read tests. Any file operation requires from OS either transfering file data to memory or memory data to disk, OS will keep those memory pages in RAM until there's preasure for RAM from other apps. In case OS receives subsequent file read/write requests through API it will simply copy the cached memory pages from previous file operstions and not utilize the actual storage device. Turning this option on is essential a test of OS's file caching subsystem and RAM speed, rather than storage device test.</value>
  </data>
  <data name="AvailableDrives" xml:space="preserve">
    <value>Available drives:</value>
  </data>
  <data name="b" xml:space="preserve">
    <value>B</value>
  </data>
  <data name="Block" xml:space="preserve">
    <value>block</value>
  </data>
  <data name="bps" xml:space="preserve">
    <value>B/s</value>
  </data>
  <data name="BreakTest" xml:space="preserve">
    <value>[Esc, B]reak test</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>[Esc, C]lose</value>
  </data>
  <data name="CsvOption" xml:space="preserve">
    <value>[E]xport test results to CSV</value>
  </data>
  <data name="FileSizeOption" xml:space="preserve">
    <value>[F]ile size:</value>
  </data>
  <data name="gb" xml:space="preserve">
    <value>GB</value>
  </data>
  <data name="GbFree" xml:space="preserve">
    <value>GB free</value>
  </data>
  <data name="gbps" xml:space="preserve">
    <value>GB/s</value>
  </data>
  <data name="HelpButton" xml:space="preserve">
    <value>[?, H]elp</value>
  </data>
  <data name="kb" xml:space="preserve">
    <value>KB</value>
  </data>
  <data name="kbps" xml:space="preserve">
    <value>KB/s</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>[L]anguage:</value>
  </data>
  <data name="Max" xml:space="preserve">
    <value>Max</value>
  </data>
  <data name="mb" xml:space="preserve">
    <value>MB</value>
  </data>
  <data name="mbps" xml:space="preserve">
    <value>MB/s</value>
  </data>
  <data name="MemCacheOption" xml:space="preserve">
    <value>In-[m]emory file cache:</value>
  </data>
  <data name="MemCopyTest" xml:space="preserve">
    <value>Memory copy</value>
  </data>
  <data name="Min" xml:space="preserve">
    <value>Min</value>
  </data>
  <data name="Off" xml:space="preserve">
    <value>(Off)</value>
  </data>
  <data name="On" xml:space="preserve">
    <value>(On)</value>
  </data>
  <data name="OptionsButton" xml:space="preserve">
    <value>[O]ptions</value>
  </data>
  <data name="PickDrive" xml:space="preserve">
    <value>- pick any drive to run perofrmance test against it</value>
  </data>
  <data name="Quit" xml:space="preserve">
    <value>[Q]uit</value>
  </data>
  <data name="Quiting" xml:space="preserve">
    <value>Terminating application...</value>
  </data>
  <data name="RandomReadTest" xml:space="preserve">
    <value>Random read</value>
  </data>
  <data name="RandomWriteTest" xml:space="preserve">
    <value>Random write</value>
  </data>
  <data name="RefreshButton" xml:space="preserve">
    <value>[R]efresh</value>
  </data>
  <data name="SequentialReadTest" xml:space="preserve">
    <value>Sequential read</value>
  </data>
  <data name="SequentialWriteTest" xml:space="preserve">
    <value>Sequential write</value>
  </data>
  <data name="StatusBreakingTest" xml:space="preserve">
    <value>BREAKING TEST</value>
  </data>
  <data name="StatusTestCompleted" xml:space="preserve">
    <value>Test has completed execution. Test file deleted</value>
  </data>
  <data name="StatusTestCsvCompleted" xml:space="preserve">
    <value>Test execution completed. Test results exported to CVS file</value>
  </data>
  <data name="StatusTestError" xml:space="preserve">
    <value>Test execution interrupted due to error</value>
  </data>
  <data name="StatusTestInterrupted" xml:space="preserve">
    <value>Test execution interrupted. Test file deleted</value>
  </data>
  <data name="TestInitMemBuffer" xml:space="preserve">
    <value>Initializing test data in RAM...</value>
  </data>
  <data name="TestNotEnoughMemory" xml:space="preserve">
    <value>Not enough memory</value>
  </data>
  <data name="TestPurgingMemCache" xml:space="preserve">
    <value>Purging memory cache...</value>
  </data>
  <data name="TestRunning" xml:space="preserve">
    <value>Running test...</value>
  </data>
  <data name="TestStarted" xml:space="preserve">
    <value>Test started</value>
  </data>
  <data name="TestSummaryFormatString" xml:space="preserve">
    <value>File size: {0} GB. Free space: {1:0.0} GB. Write Buffering: {2}. In-memory file cache: {3}</value>
  </data>
  <data name="TestWarmigUp" xml:space="preserve">
    <value>Warming up...</value>
  </data>
  <data name="WriteBufferingOption" xml:space="preserve">
    <value>Write [b]uffering:</value>
  </data>
  <data name="MemCopyTestShort" xml:space="preserve">
    <value>Mem. copy</value>
  </data>
  <data name="RandomReadTestShort" xml:space="preserve">
    <value>Rand. read</value>
  </data>
  <data name="RandomWriteTestShort" xml:space="preserve">
    <value>Rand. write</value>
  </data>
  <data name="SequentialReadTestShort" xml:space="preserve">
    <value>Seq. read</value>
  </data>
  <data name="SequentialWriteTestShort" xml:space="preserve">
    <value>Seq. write</value>
  </data>
  <data name="androidSameAliases" xml:space="preserve">
    <value>same drive, different aliases</value>
  </data>
  <data name="whiteTheme" xml:space="preserve">
    <value>[W]hite theme (restart required)</value>
  </data>
</root>