<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About1" xml:space="preserve">
    <value>This application uses standard OS's file API (WinAPI on Windows, POSIX on Mac and NDK on Android) to measure the speed of data transfer (in Megabytes per Second) between storage device (HDD, SSD, USB flash drive) and system memory(RAM). API calls are done through .NET Framework/Mono.</value>
  </data>
  <data name="About2" xml:space="preserve">
    <value>Sequential read and sequential write tests transfer large chunks of data (megabytes) between RAM and Storage. These tests are representative of such disk operations as large file copying, video recording/encoding/decoding etc.</value>
  </data>
  <data name="About3" xml:space="preserve">
    <value>Random tests run for 7 seconds each and do transfers in small chunks (4KB and 32KB) at random positions within the test file. These tests show how file system performance influence applications' load times, copying multiple small files, running database queries etc.</value>
  </data>
  <data name="About4" xml:space="preserve">
    <value>In 'Options' section you might find settings which may influence test results:</value>
  </data>
  <data name="About5" xml:space="preserve">
    <value>• Write buffering - influences write test. Write operations use intermediary memory buffer and postpone data commit to latter more convenient time for better performance at a cost of less resilient writes (e.g. power failure and not committing to disk write buffer contents).</value>
  </data>
  <data name="About6" xml:space="preserve">
    <value>• In-memory file cache - influences read tests. Any file operation requires from OS either transferring file data to memory or memory data to disk, OS will keep those memory pages in RAM until there's pressure for RAM from other apps. In case OS receives subsequent file read/write requests through API it will simply copy the cached memory pages from previous file operations and not utilize the actual storage device. Turning this option on is essential a test of OS's file caching subsystem and RAM speed, rather than storage device test.</value>
  </data>
  <data name="About7" xml:space="preserve">
    <value>Operations on computers and smartphones are executed by processor (CPU) against data which is loaded in system memory (RAM). This memory is not permanent and limited in size, that's why theres always a permanent storage (SSD, HDD, SD Card - aka "disk/drive"). In many cases the performance of the system is determined not only by CPU (which are usually in the spotlight of advertising and target of numerous benchmarks) but by the performance of memory, specifically RAM and storage. Official specs (especially with smartphones) give little description of storage characteristics, beyond capacity. This application attempts to give clear performance characteristics of memory by  isolating and measuring 3 aspects: the speed of reads (transfers from DRIVE-to-RAM). writes (RAM-to-DRIVE) and system memory (copying data from one area in RAM to another).</value>
  </data>
  <data name="About8" xml:space="preserve">
    <value>The application is open-source, you might want to check project's GitHub at:</value>
  </data>
  <data name="AndroidSameAliases" xml:space="preserve">
    <value>same drive, different aliases</value>
  </data>
  <data name="AvailableDrives" xml:space="preserve">
    <value>Available drives:</value>
  </data>
  <data name="b" xml:space="preserve">
    <value>B</value>
  </data>
  <data name="Block" xml:space="preserve">
    <value>block</value>
  </data>
  <data name="bps" xml:space="preserve">
    <value>B/s</value>
  </data>
  <data name="BreakTest" xml:space="preserve">
    <value>[Esc, B]reak test</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>[Esc, C]lose</value>
  </data>
  <data name="CsvOption" xml:space="preserve">
    <value>[E]xport test results to CSV</value>
  </data>
  <data name="FileSizeOption" xml:space="preserve">
    <value>[F]ile size:</value>
  </data>
  <data name="gb" xml:space="preserve">
    <value>GB</value>
  </data>
  <data name="GbFree" xml:space="preserve">
    <value>GB free</value>
  </data>
  <data name="gbps" xml:space="preserve">
    <value>GB/s</value>
  </data>
  <data name="HelpButton" xml:space="preserve">
    <value>[?, H]elp</value>
  </data>
  <data name="HintAndroid" xml:space="preserve">
    <value>To start tap on a drive in the list above</value>
  </data>
  <data name="HintMisc" xml:space="preserve">
    <value>To start tests click on a drive in the list above or press number key</value>
  </data>
  <data name="kb" xml:space="preserve">
    <value>KB</value>
  </data>
  <data name="kbps" xml:space="preserve">
    <value>KB/s</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>[L]anguage:</value>
  </data>
  <data name="Max" xml:space="preserve">
    <value>Max</value>
  </data>
  <data name="mb" xml:space="preserve">
    <value>MB</value>
  </data>
  <data name="mbps" xml:space="preserve">
    <value>MB/s</value>
  </data>
  <data name="MemCacheOption" xml:space="preserve">
    <value>In-[m]emory file cache:</value>
  </data>
  <data name="MemCopyTest" xml:space="preserve">
    <value>Memory copy</value>
  </data>
  <data name="MemCopyTestShort" xml:space="preserve">
    <value>Mem.&#10;copy</value>
  </data>
  <data name="Compare" xml:space="preserve">
    <value>[C]ompare</value>
  </data>
  <data name="Min" xml:space="preserve">
    <value>Min</value>
  </data>
  <data name="Off" xml:space="preserve">
    <value>(Off)</value>
  </data>
  <data name="On" xml:space="preserve">
    <value>(On)</value>
  </data>
  <data name="OptionsButton" xml:space="preserve">
    <value>[O]ptions</value>
  </data>
  <data name="PickDrive" xml:space="preserve">
    <value>- pick any drive to run perofrmance test against it</value>
  </data>
  <data name="ProjectLink" xml:space="preserve">
    <value>https://github.com/maxim-saplin/CrossPlatformDiskTest</value>
  </data>
  <data name="Quit" xml:space="preserve">
    <value>[Q]uit</value>
  </data>
  <data name="Quiting" xml:space="preserve">
    <value>Terminating application...</value>
  </data>
  <data name="RandomReadTest" xml:space="preserve">
    <value>Random read</value>
  </data>
  <data name="RandomReadTestShort" xml:space="preserve">
    <value>Rand.&#10;read</value>
  </data>
  <data name="RandomWriteTest" xml:space="preserve">
    <value>Random write</value>
  </data>
  <data name="RandomWriteTestShort" xml:space="preserve">
    <value>Rand.&#10;write</value>
  </data>
  <data name="RefreshButton" xml:space="preserve">
    <value>[R]efresh</value>
  </data>
  <data name="SequentialReadTest" xml:space="preserve">
    <value>Sequential read</value>
  </data>
  <data name="SequentialReadTestShort" xml:space="preserve">
    <value>Seq.&#10;read</value>
  </data>
  <data name="SequentialWriteTest" xml:space="preserve">
    <value>Sequential write</value>
  </data>
  <data name="SequentialWriteTestShort" xml:space="preserve">
    <value>Seq.&#10;write</value>
  </data>
  <data name="StatusBreakingTest" xml:space="preserve">
    <value>BREAKING TEST</value>
  </data>
  <data name="StatusTestCompleted" xml:space="preserve">
    <value>Test has completed execution. Test file deleted</value>
  </data>
  <data name="StatusTestCsvCompleted" xml:space="preserve">
    <value>Test execution completed. Test results exported to CVS file</value>
  </data>
  <data name="StatusTestError" xml:space="preserve">
    <value>Test execution interrupted due to error</value>
  </data>
  <data name="StatusTestInterrupted" xml:space="preserve">
    <value>Test execution interrupted. Test file deleted</value>
  </data>
  <data name="TestInitMemBuffer" xml:space="preserve">
    <value>Initializing test data in RAM...</value>
  </data>
  <data name="TestNotEnoughMemory" xml:space="preserve">
    <value>Not enough memory</value>
  </data>
  <data name="TestPurgingMemCache" xml:space="preserve">
    <value>Purging memory cache...</value>
  </data>
  <data name="TestRunning" xml:space="preserve">
    <value>Running test...</value>
  </data>
  <data name="TestStarted" xml:space="preserve">
    <value>Test started</value>
  </data>
  <data name="TestSummaryFormatString" xml:space="preserve">
    <value>File size: {0} GB. Free space: {1:0.0} GB. Write Buffering: {2}. In-memory file cache: {3}</value>
  </data>
  <data name="TestWarmigUp" xml:space="preserve">
    <value>Warming up...</value>
  </data>
  <data name="WhiteTheme" xml:space="preserve">
    <value>[W]hite theme (restart required)</value>
  </data>
  <data name="WriteBufferingOption" xml:space="preserve">
    <value>Write [b]uffering:</value>
  </data>
  <data name="CClose" xml:space="preserve">
    <value>Close</value>
  </data>
  <data name="Database" xml:space="preserve">
    <value>[D]atabase</value>
  </data>
  <data name="DbNotAvailable" xml:space="preserve">
    <value>\&gt; Results Database isn't available. Check internet connection</value>
  </data>
</root>