<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About1" xml:space="preserve">
    <value>Cette application utilise l’interface standard API du système d'exploitation (WinAPI pour Windows, POSIX pour Mac et NDK pour Android) pour mesurer la vitesse de transfert des données (mégaoctets / gigaoctets par seconde) entre le périphérique de stockage (HDD, SSD, clé USB) et la mémoire système (RAM). Les appels aux API sont réalisés via .NET Framework/Mono.</value>
  </data>
  <data name="About2" xml:space="preserve">
    <value>Les tests de lecture/écriture séquentielle mesurent la vitesse des opérations, dans lesquelles de gros blocs (mégaoctets) de données sont transmis de manière séquentielle. Ces tests représentent des opérations telles que la copie de fichiers volumineux, le codage/décodage vidéo, etc.</value>
  </data>
  <data name="About3" xml:space="preserve">
    <value>Les tests aléatoires durent plusieurs dizaines de secondes et transmettent de petits blocs de données (4 Ko) dans des positions aléatoires dans un fichier de test. Ces tests montrent comment la performance du système de fichiers influence le temps de chargement des applications et du système d'exploitation, le processus de copie de plusieurs petits fichiers, l'exécution de requêtes de base de données, etc.</value>
  </data>
  <data name="About4" xml:space="preserve">
    <value>Dans la section "Options", vous trouverez les paramètres qui peuvent affecter les résultats du test:</value>
  </data>
  <data name="About5" xml:space="preserve">
    <value>' La mise en mémoire tampon de l'écriture - influence les tests d'écriture. Lors des opérations d'écriture, le système d'exploitation peut utiliser une mémoire tampon intermédiaire et retarder l’écriture réelle data commit à des moments plus opportuns (par exemple, lorsqu’une certaine quantité de données est collectée et qu’une grande partie des données peut être sauvegardée à la fois). Ce mode augmente les performances d'écriture au moyen d'une fiabilité moindre (par exemple, dans le cas de coupure de courant certaines données peuvent être perdues).</value>
  </data>
  <data name="About6" xml:space="preserve">
    <value>' Le cache de fichier en mémoire - influence les tests de lecture. Pour toutes les opérations de fichiers, le système d'exploitation transfère les données du disque vers la mémoire (lecture) ou depuis la mémoire vers le disque (écriture). Le système d'exploitation stocke ces données dans la RAM jusqu'à ce que d'autres applications en aient besoin. À la réception de demandes de lecture/d’écriture d'un fichier, le système d'exploitation vérifie si les données ont déjà été lues depuis un fichier et si elles sont déjà en mémoire. S'il y a des données codées dans la mémoire, le système d'exploitation ne s'accédera pas au fichier et copiera de la mémoire (ce qui est beaucoup plus rapide que d'accéder au disque). En fait, l’activation de cette option ne teste pas le périphérique de stockage, mais le mécanisme de mise en cache et la RAM.</value>
  </data>
  <data name="About7" xml:space="preserve">
    <value>Sur les ordinateurs et les smartphones, le processeur central n’effectue des opérations que sur les données chargées dans la RAM. Cette mémoire n’est pas permanente et sa taille est limitée, c’est pourquoi le système dispose toujours d’une mémoire permanente (SSD, disque dur, carte SD - ci-après le "disque"). Dans de nombreux cas, la performance du système est déterminée non seulement par le processeur (qui est souvent au centre d’attention des publicités et des benchmarks), mais aussi par la performance de la mémoire, en particulier de la RAM et du disque. Les spécifications officielles (notamment celles des smartphones) présentent peu d'informations sur les caractéristiques de la mémoire, sauf peut-être celles des volumes. Cette application cherche à définir clairement les performances de la mémoire en mettant en évidence et en évaluant trois aspects: la vitesse de lecture (transfert de données du disque vers la RAM), l’écriture (de la RAM vers le disque) et la vitesse de la RAM (copie de données d’une zone de RAM à une autre).</value>
  </data>
  <data name="About8" xml:space="preserve">
    <value>Cette application est Open Source, veuillez visiter la page du projet sur Github:</value>
  </data>
  <data name="AndroidSameAliases" xml:space="preserve">
    <value>le même disque</value>
  </data>
  <data name="AvailableDrives" xml:space="preserve">
    <value>Disques disponibles:</value>
  </data>
  <data name="b" xml:space="preserve">
    <value>B</value>
  </data>
  <data name="Block" xml:space="preserve">
    <value>bloc</value>
  </data>
  <data name="bps" xml:space="preserve">
    <value>B/s</value>
  </data>
  <data name="BreakTest" xml:space="preserve">
    <value>[Esc, R]upture</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>[Esc] Fermer</value>
  </data>
  <data name="CsvOption" xml:space="preserve">
    <value>[E]xporter les résultats  au format CSV</value>
  </data>
  <data name="FileSizeOption" xml:space="preserve">
    <value>[T]aille du fichier:</value>
  </data>
  <data name="gb" xml:space="preserve">
    <value>GB</value>
  </data>
  <data name="GbFree" xml:space="preserve">
    <value>GB disponibles</value>
  </data>
  <data name="gbps" xml:space="preserve">
    <value>GB/s</value>
  </data>
  <data name="HelpButton" xml:space="preserve">
    <value>[?] Aide</value>
  </data>
  <data name="HintAndroid" xml:space="preserve">
    <value>Tapez sur le disque ci-dessus pour lancer un test</value>
  </data>
  <data name="HintMisc" xml:space="preserve">
    <value>Pour lancer un test cliquez sur un des disques ou sur la touche avec son numéro</value>
  </data>
  <data name="kb" xml:space="preserve">
    <value>Ko</value>
  </data>
  <data name="kbps" xml:space="preserve">
    <value>Ko/s</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>[L]angue:</value>
  </data>
  <data name="Max" xml:space="preserve">
    <value>Max</value>
  </data>
  <data name="mb" xml:space="preserve">
    <value>MB</value>
  </data>
  <data name="mbps" xml:space="preserve">
    <value>MB/s</value>
  </data>
  <data name="MemCacheOption" xml:space="preserve">
    <value>[M]émoire cache de fichier:</value>
  </data>
  <data name="MemCopyTest" xml:space="preserve">
    <value>Copie de la mémoire</value>
  </data>
  <data name="MemCopyTestShort" xml:space="preserve">
    <value>Copie
mémoire</value>
  </data>
  <data name="MemCopyTestShortNB" xml:space="preserve">
    <value>Copie mémoire</value>
  </data>
  <data name="Min" xml:space="preserve">
    <value>Min</value>
  </data>
  <data name="Off" xml:space="preserve">
    <value>(Off)</value>
  </data>
  <data name="On" xml:space="preserve">
    <value>(On)</value>
  </data>
  <data name="OptionsButton" xml:space="preserve">
    <value>[O]ptions</value>
  </data>
  <data name="PickDrive" xml:space="preserve">
    <value>- Sélectionnez l'un des disques ci-dessus pour lancer un test</value>
  </data>
  <data name="Quit" xml:space="preserve">
    <value>[Q, Q]itter</value>
  </data>
  <data name="Quiting" xml:space="preserve">
    <value>Quitter</value>
  </data>
  <data name="RandomReadTest" xml:space="preserve">
    <value>Lecture séquentiel </value>
  </data>
  <data name="RandomReadTestShort" xml:space="preserve">
    <value>Lecture
aléat.</value>
  </data>
  <data name="RandomReadTestShortNB" xml:space="preserve">
    <value>Lecture aléat.</value>
  </data>
  <data name="RandomWriteTest" xml:space="preserve">
    <value>Ecriture aléatoire </value>
  </data>
  <data name="RandomWriteTestShort" xml:space="preserve">
    <value>Ecriture
aléat.</value>
  </data>
  <data name="RandomWriteTestShortNB" xml:space="preserve">
    <value>Ecriture aléatoire</value>
  </data>
  <data name="RefreshButton" xml:space="preserve">
    <value>[R]afraichir</value>
  </data>
  <data name="SequentialReadTest" xml:space="preserve">
    <value>Lecture séq.</value>
  </data>
  <data name="SequentialReadTestShort" xml:space="preserve">
    <value>Lecture
séq.</value>
  </data>
  <data name="SequentialReadTestShortNB" xml:space="preserve">
    <value>Lecture séq.</value>
  </data>
  <data name="SequentialWriteTest" xml:space="preserve">
    <value>Ecriture séq.</value>
  </data>
  <data name="SequentialWriteTestShort" xml:space="preserve">
    <value>Ecriture
séq.</value>
  </data>
  <data name="SequentialWriteTestShortNB" xml:space="preserve">
    <value>Ecriture séq.</value>
  </data>
  <data name="StatusBreakingTest" xml:space="preserve">
    <value>RUPTURE DU TEST</value>
  </data>
  <data name="StatusTestCompleted" xml:space="preserve">
    <value>Test terminé. Fichier test supprimé</value>
  </data>
  <data name="StatusTestCsvCompleted" xml:space="preserve">
    <value>Test terminé. Résultats exportés au format CSV</value>
  </data>
  <data name="StatusTestError" xml:space="preserve">
    <value>Exécution du test est interrompue suite à une erreur</value>
  </data>
  <data name="StatusTestInterrupted" xml:space="preserve">
    <value>L'exécution du test est interrompue. Le fichier test est supprimé</value>
  </data>
  <data name="TestInitMemBuffer" xml:space="preserve">
    <value>Initialisation de données de test dans la RAM</value>
  </data>
  <data name="TestNotEnoughMemory" xml:space="preserve">
    <value>Mémoire insuffisante</value>
  </data>
  <data name="TestPurgingMemCache" xml:space="preserve">
    <value>Vidage de mémoire cache...</value>
  </data>
  <data name="TestRunning" xml:space="preserve">
    <value>Test en cours...</value>
  </data>
  <data name="TestStarted" xml:space="preserve">
    <value>Test commencé</value>
  </data>
  <data name="TestSummaryFormatString" xml:space="preserve">
    <value>Taille du fichier: {0} GB. Disponible: {1:0.0} GB.  Écriture bufferisée: {2}. Mémoire cache de fichier: {3}</value>
  </data>
  <data name="TestSummaryShortFormatString" xml:space="preserve">
    <value>Fichier:{0}GB Disponible:{1:0.0}GB Écrit. bufferisée:{2} Cache:{3}</value>
  </data>
  <data name="TestWarmigUp" xml:space="preserve">
    <value>Préparation...</value>
  </data>
  <data name="WhiteTheme" xml:space="preserve">
    <value>Thème [b]lanc (redémarrage demandé)</value>
  </data>
  <data name="WriteBufferingOption" xml:space="preserve">
    <value>[E]criture bufferisée:</value>
  </data>
  <data name="CClose" xml:space="preserve">
    <value>Fermer</value>
  </data>
  <data name="Database" xml:space="preserve">
    <value>[R]ésultats</value>
  </data>
  <data name="DbNotAvailable" xml:space="preserve">
    <value>Base de données indisponible. Veuillez vérifier la connexion Internet</value>
  </data>
  <data name="Compare" xml:space="preserve">
    <value>⇆ Comparer </value>
  </data>
  <data name="Share" xml:space="preserve">
    <value>⬑Partager⬏</value>
  </data>
  <data name="ShareTitle" xml:space="preserve">
    <value>CPDT Benchmark:  https://play.google.com/store/apps/details?id=com.Saplin.CPDT</value>
  </data>
  <data name="About9" xml:space="preserve">
    <value>Télécharger l'application pour Windows, macOS, Android/APK:</value>
  </data>
  <data name="DownloadLink" xml:space="preserve">
    <value>https://maxim-saplin.github.io/cpdt_results/?download=&amp;lang=ru&amp;app=</value>
  </data>
  <data name="ModeH" xml:space="preserve">
    <value>Mode</value>
  </data>
  <data name="About10" xml:space="preserve">
    <value>Chaque test est accompagné d’un graphique, fourni pour chacun des tests. Les tests séquentiels et le test de copie en mémoire sont représentés par un graphique linéaire de la vitesse instantanée - c.-à-d. les vitesses, mesurées pour chacun des blocs, sont représentées par le X, et les positions de ces blocs dans le fichier sont représentées par le Y. Ainsi, vous pouvez voir comment la vitesse change à mesure de la progression à la fin du fichier de test. Par exemple, dans certains cas, vous pouvez constater des performances réduites au début du test (ce qui est typique pour l’Android). Les tests aléatoires représentent un histogramme, où les vitesses mesurées pour les blocs, sont réparties sur une plage, et les colonnes indiquent la fréquence de telle ou telle plage S'il y a des lignes verticales avec des flèches sur les bords de l’histogramme, les colonnes gauche et droite affichent toutes les mesures, les plus faibles et les plus élevées, dont la fréquence d'occurrence est inférieure à 3%. Autrement dit, les "longues" queues de l'histogramme forment des colonnes séparées, les colonnes au centre affichent des données résultant des 94% de toutes les mesures. Dans ce cas-là, les valeurs minimum et maximum ne sont pas indiquées pour toutes les mesures, mais uniquement pour les valeurs moyennes. La colonne surlignée par deux flèches correspond à la valeur modale, valeur moyenne de la plage avec la plus grande fréquence.</value>
  </data>
  <data name="SimpleUI_StartA" xml:space="preserve">
    <value>Lancer un</value>
  </data>
  <data name="SimpleUI_Test" xml:space="preserve">
    <value>[T]est</value>
  </data>
  <data name="SimpleUI_OrSee" xml:space="preserve">
    <value>ou voir</value>
  </data>
  <data name="SimpleUI_More" xml:space="preserve">
    <value>[P]lus</value>
  </data>
  <data name="SimpleUIOption" xml:space="preserve">
    <value>[T]hème ordinaire</value>
  </data>
  <data name="CantTestNotEnough" xml:space="preserve">
    <value>Impossible de tester certaines partitions. 1.6GB d'espace libre sont exigés</value>
  </data>
  <data name="TestOf" xml:space="preserve">
    <value>Test {0} de {1}</value>
  </data>
  <data name="TestTotal" xml:space="preserve">
    <value>Terminé {0:0}%</value>
  </data>
  <data name="InitDrivesError" xml:space="preserve">
    <value>Une erreur s'est produite lors de la récupération de la liste des disques/partitions. Impossible de lancer le test.</value>
  </data>
  <data name="NotEnoughSpaceHint" xml:space="preserve">
    <value>insuffisant</value>
  </data>
  <data name="NotAccessibleDriveHint" xml:space="preserve">
    <value>indisponible</value>
  </data>
</root>